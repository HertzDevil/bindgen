# Configuration template - Base your bindgen configuration on this!

# A note on templates: Some values are "templated".  This means they're of type
# `String`.  All occurences of the percent-sign ("%") will be replaced by a
# computed value.
# Additionally, templated strings allow access to environment variables  using
# curly braces: `{CC}` would be expanded to the value of `ENV["CC"]`.  It's
# possible to provide a fall back value, which is used only if the given
# environment variable doesn't exist: `{CC|gcc}` would expand to `ENV["CC"]`,
# or if it is not set, to `gcc`.  You can also put a percent-sign in there:
# `{LIBRARY_PATH|%}` will expand to `ENV["LIBRARY_PATH"]`, or to the replacement
# value otherwise.

# Defines the `module X` into which *all* code will be put.
#   Mandatory!
module: MyStuff

# Defines the `ld_flags` value for the `@[Link]` directive of the generated `lib`.
# `%` will be replaced by the path to the base-directory of your project,
# relative to the path of the generated `.cr` file.
library: "%/ext/binding.a"

# Processors pipeline.  See `README.md` for details.
# The following pipeline is what you probably want to use for C++.
processors:
  # Graph-refining processors:
  - filter_methods # Throw out filtered methods
  - default_constructor # Create default constructors where possible
  - copy_structs # Copy structures as marked
  - macros # Support for macro mapping
  - auto_container_instantiation # Figure out which templates to instantiate
  - instantiate_containers # Actually instantiate containers
  - virtual_override # Allow overriding virtual methods
  # Preliminary generation processors:
  - cpp # Create C++ <-> C wrappers
  - crystal_binding # Create `lib` bindings for the C wrapper
  - crystal # Create Crystal wrappers
  - sanity_check # Shows issues, if any

# Generator configuration.  These write the actual output to disk.
generators:
  # C++ generator
  cpp:
    # Output file path  (Mandatory)
    output: ext/my_bindings.cpp
    # Output file preamble  (Optional)
    preamble: |-
      #include "bindgen_helper.hpp"
    # Command to run after the generator.  (Optional!)
    # Will be executed as-written in the output directory.
    # If the command signals failure, bindgen will halt too.
    build: make
    # Small-ish bindings may get away without a custom Makefile:
    # build: "{CXX|g++} -std=c++11 -c -o binding.o -lMyLib my_bindings.cpp"
    # Do you have complex dependencies?  Use a conditional!
    # if_os_is_windows: # Read the `YAML configuration` section in README.md
    #   build: mingw-make
  # Crystal generator.  Configuration style is exactly the same.
  crystal:
    # You'll most likely only need the `output` option.
    output: src/my_lib/binding.cr

# Map of classes to bind to.  A class inheriting another class should follow
# *after* that base-class.
classes:
  # Maps from the name of the C++ class, to the Crystal class.
  CppClassName: CrystalClassName
  MayBeEqual: MayBeEqual # This is fine, too.

# Map of enums to copy.
enums:
  # Maps from the name of the C++ enum, to the Crystal enum.
  # `CrystalEnumName` can reside in a wrapped class.
  CppEnumName: CrystalEnumName

# Map of macros (`#define`s) to copy.
macros:
  # Maps from a *regular expression*.  Rules are tried in the order they're
  # defined in the configuration file.  The expression must match the whole name
  # of the macro case-sensitively to be copied.
  "FOO_BAR_(.*)":
    # How to map matching macros:  Either put all into an enum, or as constant.
    map_as: Enum | Constant
    # Only if mapping as enum:  Treat as @[Flags] enum?
    # Defaults to `false`.
    flags: true | false
    # Only if mapping as enum:  C++ type to map as.  Defaults to "int".
    type: int
    # How the enum constants, or constants, name should end up.  Access to
    # capture groups in the regular expression is done using `\\n` to access the
    # n-th capture group.  The name will be post-processed automatically.
    #
    # If left out, the first capture group will be used.
    name: "\\1"
    # Where to store the matching constants.  For a enum, this is the path to
    # the enum itself (So, including the enums name).  For a constant, this is
    # the path to the class (or module) it will be stored in.
    destination: Foo::Bar

# List of container-types to wrap.  (Keyword: C++ Templates)
containers:
  - class: Name of the C++ class
    type: "Sequential" or "Associative"
    # access_method: C++ item access method.  Defaults to `at`.
    # size_method: C++ container size method.  Defaults to `size`.
    # push_method: C++ item append method.  Defaults to `push_back`.
    instantiations: # All wanted instantiations of this container
      # You may like the `AutoContainerInstantiation` processor, too!
      - [ "C++ type name" ]
      # - [ "..." ]

# Configuration for the C++ parser.
parser:
  # Path to the `bindgen-clang` binary.  (Optional!)
  binary: path/to/bindgen-clang
  # Additional Clang flags.  Example for C++11:
  flags:
    - -x
    - c++
    - -std=c++11
  # List of files to include.  Can be relative to search-paths.
  files:
    - my_lib.h
  # List of incldue search-paths.  Example points to Clangs standard library.
  includes:
    - /usr/lib/clang/4.0.1/include/
  # Additional "#define"s passed to Clang.
  defines:
    - __STDC_CONSTANT_MACROS
    - __STDC_LIMIT_MACROS

# Additional type configuration, of both explicitly wrapped types and all other
# found types.  All fields are optional.
# Commonly referred to "type rules", or just "rules" in the source code.
types:
  FullCppTypeName: # Full name of the C++ Type (Like `std::string`)
    # Ignore everything else in this map, and look-up the other type for rules.
    alias_for: FullCppTypeName

    # If all methods found using this type shall be ignored.
    # Useful to quickly get started.
    ignore: true | false

    # Override the kind of this type.  Changes passing-behaviour.
    # Defaults to `Class`.
    kind: Class | Struct | Value | Enum

    # Name of this type in the wrapper.
    crystal_type: CrystalTypeName

    # Name of this type in the C++ binding.  Useful when used with converters.
    cpp_type: CppTypeName

    # Name of this type in `lib Binding`.
    binding_type: CrystalTypeName

    # Inserted into C++ to turn the type into something the `binding_type` will
    # be able to understand.  Template value is the whole C++ call.
    from_cpp: "convert_from_cpp(%)"

    # Inserted into C++ to turn the `binding_type` into something C++ can
    # understand.  Template value is the C++ argument name.
    to_cpp: "convert_to_cpp(%)"

    # Crystal converter module used to turn the binding-type into a crystal-type
    # and back.
    #
    # module TheConverter
    #   def wrap(value : CrystalType) : BindingType
    #   def unwrap(value : BindingType) : CrystalType
    # end
    converter: TheConverter

    # Pendant to `to_cpp` in Crystal.  `converter` takes precedence.
    # Template value is the whole binding call.
    to_crystal: "CrystalType.from_cpp(%)"

    # Pendant to `from_cpp` in Crystal.  `converter` takes precedence.
    # Template value is the wrapper argument.
    from_crystal: "%.to_cpp"

    # Override of the pass-by semantics.  Use with caution.  Usually not
    # required.  Defaults to `Original`.
    pass_by: Original | Reference | Pointer | Value

    # Override of the pass-by semantics only in the user-facing wrapper code.
    # Defaults to the value of `pass_by:` from above.
    wrapper_pass_by: Original | Reference | Pointer | Value

    # Enable or disable check if this type should be sub-classed to allow
    # overriding virtual methods of the wrapped type in Crystal.
    # If the type has no virtual methods, no sub-class will be generated.
    # Defaults to `true`.
    sub_class: true | false

    # Copy the read structure fields over to Crystal.  Useful for simple C-style
    # structures.  `struct` will end up in `Binding::BindingName`.
    # Defaults to `false`.
    copy_structure: true | false

    # Treat this type as built-in type in C++ and Crystal.
    # Defaults to `false`.
    builtin: true | false

    # Generate the user-facing wrapper class for this type.
    # Defaults to `true`.
    generate_wrapper: true | false

    # Generate the `fun` bindings of all wrapped methods of this type.
    # Defaults to `true`.
    generate_binding: true | false

    # List of methods to ignore in only this type when wrapping.
    ignore_methods:
      - some_method_name
