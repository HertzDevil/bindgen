#!/usr/bin/env crystal run

# Helper script: Builds the `generated.hpp` containing the system include paths.
# Also outputs all LLVM and Clang libraries to link to.  Provides diagnostics
# to standard error.  Called by the `Makefile`.

# Find clang++ binary, through user setting, or automatically.
if binary = ENV["CLANG"]?
  unless File.exists? binary
    STDERR.puts "No binary found at #{binary.inspect}"
    STDERR.puts "Make sure your CLANG environment variable points at the clang++ binary"
    exit 1
  end

  clang_binary = binary
elsif binary = Process.find_executable("clang++")
  clang_binary = binary
else
  STDERR.puts "Failed to find clang++ binary."
  STDERR.puts "You can provide the path to it through the CLANG environment variable."
  exit 1
end

STDERR.puts "Using clang binary #{clang_binary.inspect}"

# Ask clang the paths it uses.
output = `#{clang_binary} -### #{__DIR__}/src/bindgen.cpp 2>&1`.lines

if output.size < 2 # Sanity check
  STDERR.puts "Unexpected output: Expected at least two lines."
  exit 1
end

# Untangle the output
raw_cppflags = output[-2]
raw_ldflags = output[-1]

# Shell-split
def shell_split(line)
  list = [ ] of String
  skip_next = false
  in_string = false
  offset = 0

  # Parse string
  line.each_char_with_index do |char, idx|
    if skip_next
      skip_next = false
      next
    end

    case char
    when '\\' # Escape character
      skip_next = true
    when ' ' # Split character
      unless in_string
        list << line[offset...idx]
        offset = idx + 1
      end
    when '"' # String marker
      in_string = !in_string
    end
  end

  list.reject(&.empty?).map do |x|
    # Remove surrounding double-quotes
    if x.starts_with?('"') && x.ends_with?('"')
      x[1..-2]
    else
      x
    end
  end
end

# Shell split the strings.  Remove first of each, as this is the program name.
cppflags = shell_split(raw_cppflags)[1..-1]
ldflags = shell_split(raw_ldflags)[1..-1]

#
system_includes = [ ] of String
system_libs = [ ] of String

# Interpret the argument lists
flags = cppflags + ldflags
index = 0
while index < flags.size
  case flags[index]
  when "-internal-isystem"
    system_includes << flags[index + 1]
    index += 1
  when /^-L/
    system_libs << flags[index][2..-1]
  end

  index += 1
end

# Generate the output header file.  This will be accessed from the clang tool.
output_path = "#{__DIR__}/include/generated.hpp"
output_code = String.build do |b|
  b.puts "// Generated by #{__FILE__}"
  b.puts "// DO NOT CHANGE"
  b.puts
  b.puts "#define BG_SYSTEM_INCLUDES { #{system_includes.map(&.inspect).join(", ")} }"
end

# Only write if there's a change.  Else we break make's dependency caching and
# constantly rebuild everything.
if !File.exists?(output_path) || File.read(output_path) != output_code
  File.write(output_path, output_code)
end

# Find all LLVM and clang libraries, and link to all of them.  We don't need
# all of them - Which totally helps with keeping linking times low.
def find_libraries(paths, prefix)
  paths
    .flat_map{|path| Dir["#{path}/lib#{prefix}*.a"]}
    .map{|path| File.basename(path)[/^lib([^.]+)\.a$/, 1]}
    .uniq
end

llvm_libs = find_libraries(system_libs, "LLVM")
clang_libs = find_libraries(system_libs, "clang")

# Libraries must precede their dependencies.  By putting the whole list twice
# into the compiler, we ensure this.  The probably laziest dependency resolution
# algorithm in existence.
puts (clang_libs + clang_libs + llvm_libs + llvm_libs).map{|x| "-l#{x}"}.join(" ")
