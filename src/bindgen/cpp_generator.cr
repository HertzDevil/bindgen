module Bindgen
  class CppGenerator < Generator
    def initialize(@db : TypeDatabase, @io : IO)
      @classes = { } of String => Parser::Class
      @methods = { } of Parser::Method => Parser::Type
      @containers = [ ] of Configuration::Container
    end

    # Prints the prologue comment header telling the user to not change the
    # file.
    def print_header
      @io.puts "// GENERATED CODE - DO NOT CHANGE"
      @io.puts "//   Generated by bindgen.cr"
      @io.puts "//   Time: #{Time.now}"
      @io.puts "// See: https://github.com/Papierkorb/bindgen"
      @io.puts ""
      @io.puts "// Break C++:"
      @io.puts "#define protected public"
      @io.puts ""
    end

    # Prints *data* verbatim into the output
    def print(data)
      @io.puts data if data
    end

    # Adds a C++ `#include` directive to *path*, using *global* first lookup or
    # not.
    def add_include(path : String, global = true)
      if global
        @io.puts %{#include <#{path}>}
      else
        @io.puts %{#include "#{path}"}
      end
    end

    # Adds a C++ wrapper for *klass*.
    def add_class(klass : Parser::Class)
      @classes[klass.name] = klass
      unless @db.try_or(klass.name, true, &.generate_binding)
        return # The user wants to write manual bindings.
      end

      klass_type = klass.as_type(pointer: 1)
      write_destructor klass

      klass.wrap_methods.each do |method|
        add_method?(method, klass_type)
      end

      write_as_other_type_methods(klass)
      if is_class_subclassed?(klass)
        write_virtual_subclass(klass)
        write_virtual_subclass_setter(klass)
      end
    end

    # Adds a container *template* instantiation configuration.
    def add_container(template : Configuration::Container)
      @containers << template
    end

    # Writes all necessary `_AS_` methods of *klass*.
    private def write_as_other_type_methods(klass : Parser::Class)
      wrapped_base_classes_of(klass, range: 1..-1).each do |base|
        write_as_other_type_method(klass, base)
      end
    end

    # Writes a single `_AS_` method, converting from *klass* to *target*, using
    # a proper C++ `static_cast<T*>(self)`.  This is required for types using
    # multiple-inheritance!
    private def write_as_other_type_method(klass : Parser::Class, target : Parser::Class)
      source_ptr = with_pointer klass.name
      target_ptr = with_pointer target.name

      @io.puts %[extern "C" #{target_ptr} #{klass.converter_name(target)}(#{source_ptr} self) {]
      @io.puts %[  return static_cast< #{target_ptr} >(self);]
      @io.puts %[}]
    end

    # Generates a destructor for *klass*
    def write_destructor(klass : Parser::Class)
      @io.puts %<extern "C" void #{klass.destructor_name}(#{klass.name}* _self_) { delete _self_; }\n\n>
    end

    # Stores a C++ wrapper for *method* if it's not filtered per
    # `Parser::Method#filtered?`.
    def add_method?(method : Parser::Method, type)
      unless @db.try_or(method.class_name, true, &.generate_binding)
        return # The user wants to write manual bindings.
      end

      add_method(method, type) unless method.filtered?(@db)
    end

    # Stores a C++ wrapper for *method*.
    def add_method(method : Parser::Method, type)
      @methods[method] = type
    end

    def emit_all_methods
      @containers.each do |container|
        write_container_bindings container
      end

      @methods.each do |method, klass_type|
        write_signal_connect_method(method, klass_type) if method.signal?
        write_method(method, klass_type)
      end
    end

    private def write_method(method : Parser::Method, type : Parser::Type)
      analyzer = CallAnalyzer::CrystalToCpp.new(@db)
      generator = CallGenerator::CppWrapper.new

      target = method.class_name
      target = subclass_name(target) if is_class_subclassed?(@classes[type.base_name])

      call = analyzer.analyze(method, target)
      @io.puts generator.generate(call)
    end

    # Writes the bindings to access *container*.
    private def write_container_bindings(container)
      if container.type.sequential?
        container.instantiations.each do |args|
          next if args.size != 1
          write_sequential_container_binding(container, args)
        end
      end
    end

    # Writes the *instantiation* binding for the template *container*.
    private def write_sequential_container_binding(container, instantiation)
      type_name = instantiation.first
      var_type = Parser::Type.parse(type_name)

      klass = build_sequential_container_class(container, var_type)
      cpp_type_name = container_cpp_type_name(container, instantiation)
      write_typedef(original: cpp_type_name, new: klass.name)
      add_class(klass)
    end

    # Writes a `typedef`, defining the type *new* from the *original* type.
    private def write_typedef(original : String, new : String)
      @io.puts "typedef #{original} #{new};"
    end

    # Assumes that *method* is a Qt signal, and thus writes a method that can be
    # used to connect to the signal.
    private def write_signal_connect_method(method : Parser::Method, type)
      proc_analyzer = CallAnalyzer::CppToCrystalProc.new(@db)
      lambda_analyzer = CallAnalyzer::CppToCrystal.new(@db)
      cpp = CallAnalyzer::CrystalToCpp.new(@db)
      proc_gen = CallGenerator::CppCrystalProc.new(type_only: true)
      connect_gen = CallGenerator::CppQObjectConnect.new
      wrapper_gen = CallGenerator::CppWrapper.new
      conn_method, _proc_method = generate_signal_connect_binding_method(method)

      proc_call = proc_analyzer.analyze(method, "_proc_")
      lambda_call = lambda_analyzer.analyze(method, "_proc_")
      conn_call = cpp.analyze(conn_method)

      conn_call.arguments.clear # HACK
      conn_call.arguments << proc_gen.as_result(proc_call).to_argument("_proc_")

      code = wrapper_gen.generate(conn_call) do |pass_args|
        connect_gen.generate(conn_call, lambda_call)
      end

      @io.puts code
      @io.puts ""
    end

    # Writes a sub-class of *klass*, forwarding all methods to it by inheritance
    # if possible.  Each virtual method seen will get a check if it has been
    # overwritten from Crystal world, and if so, is called instead of the
    # default method.  Pure methods call directly into the Crystal world, the
    # Crystal compiler will make sure no one can build a class without
    # implementing these.
    private def write_virtual_subclass(klass : Parser::Class)
      table_name = subclass_table_name(klass)
      redirected_methods = unique_virtual_methods(klass)

      write_redirection_table(table_name, redirected_methods)

      @io.puts "struct #{subclass_name(klass)} : public #{klass.name} {"
      # Inherit all constructors from the wrapped class
      @io.puts "  using #{klass.name}::#{klass.name};"
      @io.puts "  #{table_name} bg_table;\n\n"
      write_redirection_methods(klass, redirected_methods, klass.name)
      @io.puts "};\n"
    end

    # Writes the C++ struct of redirected methods, consisting of a `CrystalProc`
    # for each.
    private def write_redirection_table(table_name, redirected_methods)
      analyzer = CallAnalyzer::CppToCrystalProc.new(@db)
      generator = CallGenerator::CppCrystalProc.new

      @io.puts "struct #{table_name} {"

      redirected_methods.each do |_, method|
        var_name = "jump_#{method.mangled_name}"
        call = analyzer.analyze(method, var_name)
        @io.puts generator.generate(call)
      end

      @io.puts "};\n"
    end

    # Writes the redirection methods of all virtual methods in *klass*,
    # including all virtual methods of all wrapped base classes.
    private def write_redirection_methods(klass, redirected_methods, parent)
      redirected_methods.each do |methods_class, method|
        write_redirection_method(method)
      end
    end

    # Writes the implementation of the virtual *method*.
    # The implementation checks if there is a Crystal implementation of this
    # method.  If yes, calls it.  Else, it falls back to the implementation of
    # the *parent*.
    private def write_redirection_method(method : Parser::Method)
      to_cpp = CallAnalyzer::CppToCpp.new(@db)
      to_crystal = CallAnalyzer::CppToCrystalProc.new(@db)

      jump_var = "this->bg_table.jump_#{method.mangled_name}"
      cpp_call = to_cpp.analyze(method)
      crystal_call = to_crystal.analyze(method, jump_var)

      virtual = CallGenerator::CppVirtual.new

      @io.puts virtual.generate(crystal_call, cpp_call)
      @io.puts
    end

    # Writes the sub-class implementations pointer method.  This allows Crystal
    # code to initialize the jump-table, and thus enable a call into Crystal
    # world.
    private def write_virtual_subclass_setter(klass)
      class_name = subclass_name(klass)
      table_name = subclass_table_name(klass)
      func_name = class_jumptable_setter_name(klass)

      @io.puts %[extern "C" void #{func_name}(#{class_name} *self, const #{table_name} &table) {]
      @io.puts %[  self->bg_table = table;]
      @io.puts %[}\n\n]
    end

    # Name of the generated sub-class of *klass*.
    private def subclass_name(klass : String | Parser::Class) : String
      klass = klass.name if klass.is_a?(Parser::Class)
      "BgInherit_#{klass}"
    end

    # Name of the generated function-pointer table struct for *klass*.
    private def subclass_table_name(klass : String | Parser::Class) : String
      klass = klass.name if klass.is_a?(Parser::Class)
      "BgTable_#{klass}"
    end
  end
end
